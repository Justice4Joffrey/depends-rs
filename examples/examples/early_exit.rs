use std::{
    collections::HashSet,
    hash::{Hash, Hasher},
    rc::Rc,
};

use depends::{
    derives::{Dependencies, Operation, Value},
    error::{EarlyExit, ResolveError},
    Dependency, DerivedNode, InputNode, Resolve, SingleRef, TargetMut, UpdateDerived, UpdateInput,
};

/// A dummy tracker for the number of open orders.
#[derive(Value, Default)]
pub struct OpenOrders {
    pub value: Vec<i32>,
    /// Keep track of every time this node is updated, use that as the hash.
    #[depends(hash)]
    generation: usize,
}

#[derive(Copy, Clone, Debug, Hash)]
pub enum OpenOrdersOperation {
    Add(i32),
    Cancel,
}

// By implementing UpdateInput, we can change the value of this node from
// outside of the graph.
impl UpdateInput for OpenOrders {
    type Update = OpenOrdersOperation;

    fn update_mut(&mut self, update: Self::Update) {
        match update {
            OpenOrdersOperation::Add(order) => self.value.push(order),
            OpenOrdersOperation::Cancel => {
                self.value.remove(0);
            }
        }
        self.generation += 1;
    }
}

/// This node is only used to raise an error if the number of open orders is
/// too high.
#[derive(Value, Hash, Debug)]
pub struct RiskLimit {
    max_orders: usize,
}

impl RiskLimit {
    pub fn new(max_orders: usize) -> Self {
        Self { max_orders }
    }
}

#[derive(Operation)]
struct CheckRiskLimit;

// Note [TwoNumbersRef] is generated by the [Dependencies] macro, and
// represents read-references to all of its fields.
impl UpdateDerived for CheckRiskLimit {
    type Input<'a> = SingleRef<'a, OpenOrders> where Self: 'a;
    type Target<'a> = TargetMut<'a, RiskLimit> where Self: 'a;

    fn update_derived(
        input: SingleRef<'_, OpenOrders>,
        target: TargetMut<'_, RiskLimit>,
    ) -> Result<(), EarlyExit> {
        let orders = input.value.len();
        if orders >= target.max_orders {
            Err(EarlyExit::new(format!("Risk limit exceeded ({})", orders)))
        } else {
            Ok(())
        }
    }
}

/// An expensive calculation that we only want to perform if we're ok to
/// continue trading.
#[derive(Value, Hash, Default, Debug)]
pub struct ExpensiveCalculation {
    pub next_number: i32,
}

#[derive(Operation)]
struct CalculateNextNumber;

impl UpdateDerived for CalculateNextNumber {
    type Input<'a> = SingleRef<'a, OpenOrders> where Self: 'a;
    type Target<'a> = TargetMut<'a, ExpensiveCalculation> where Self: 'a;

    fn update_derived(
        _: SingleRef<'_, OpenOrders>,
        mut target: TargetMut<'_, ExpensiveCalculation>,
    ) -> Result<(), EarlyExit> {
        println!("Expensive calculation performed!");
        target.next_number += 1;
        Ok(())
    }
}

/// The factors which our final decision depends on.
#[derive(Dependencies)]
pub struct Factors {
    open_orders: OpenOrders,
    risk_limit: RiskLimit,
    expensive: ExpensiveCalculation,
}

#[derive(Value, Hash, Default, Debug)]
pub struct DecisionNode {
    value: Option<OpenOrdersOperation>,
}

/// We must define the transformation functions for each derived node.
/// Given a set of inputs and a target value, describe how to update the
/// state. In this example, it's just a simple addition.
#[derive(Operation)]
struct Decide;

impl UpdateDerived for Decide {
    type Input<'a> = FactorsRef<'a> where Self: 'a;
    type Target<'a> = TargetMut<'a, DecisionNode> where Self: 'a;

    fn update_derived(
        FactorsRef { expensive, .. }: FactorsRef<'_>,
        mut target: TargetMut<'_, DecisionNode>,
    ) -> Result<(), EarlyExit> {
        target.value = Some(OpenOrdersOperation::Add(expensive.next_number));
        Ok(())
    }
}

fn main() {
    // Our only input node to this graph is the number of open orders.
    let open_orders = InputNode::new(OpenOrders::default());

    let risk_node = DerivedNode::new(
        Dependency::new(Rc::clone(&open_orders)),
        CheckRiskLimit,
        RiskLimit::new(5),
    );
    let expensive_node = DerivedNode::new(
        Dependency::new(Rc::clone(&open_orders)),
        CalculateNextNumber,
        ExpensiveCalculation::default(),
    );
    // It's not _necessary_ to create edges from risk_limit and open_orders to
    // this node, because they are already transitively connected through
    // `expensive_node`.
    let decision = DerivedNode::new(
        Factors::init(Rc::clone(&open_orders), risk_node, expensive_node),
        Decide,
        DecisionNode::default(),
    );

    let mut visitor = HashSet::<usize>::new();
    for i in 0..=10 {
        println!("------------");
        println!("Iteration {}", i);
        // Resolve the graph.
        let decision = match decision.resolve_root(&mut visitor) {
            Ok(order) => order.value.unwrap(),
            Err(ResolveError::EarlyExit(e)) => {
                println!("Early exit: {}, popping order", e);
                OpenOrdersOperation::Cancel
            }
            _ => panic!("Unexpected error"),
        };
        println!("Decision: {:?}", decision);
        // Update the graph
        open_orders.update(decision).unwrap();
        println!("Current orders: {:?}", open_orders.value().unwrap().value);
    }
}
