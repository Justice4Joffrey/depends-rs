use depends::{derives::Graph, *};
use serial_test::serial;

use crate::docs::{multiple_dependencies::*, raising_the_stakes::*, simple_value::*};

// ANCHOR: graph_creator
// This is the graph generated by the previous example with slightly more
// descriptive node names.
#[derive(Graph)]
#[depends(
    digraph MyDag {
        a [label="SomeNumber"];
        b [label="SomeNumber"];
        c [label="SomeNumber"];
        d [label="SomeNumber"];
        e [label="SomeNumber"];
        a_times_b [label="SomeNumber"];
        a -> a_times_b [label="Multiply", class="Dependencies2"];
        b -> a_times_b [label="Multiply", class="Dependencies2"];
        d_minus_c [label="SomeNumber"];
        d -> d_minus_c [label="Subtract", class="Dependencies2"];
        c -> d_minus_c [label="Subtract", class="Dependencies2"];
        d_squared [label="SomeNumber"];
        d -> d_squared [label="Square"];
        e_squared [label="SomeNumber"];
        e -> e_squared [label="Square"];
        a_times_b_plus_c_minus_d [label="SomeNumber"];
        a_times_b -> a_times_b_plus_c_minus_d [label="Add", class="Dependencies2"];
        d_minus_c -> a_times_b_plus_c_minus_d [label="Add", class="Dependencies2"];
        times_e_squared [label="SomeNumber"];
        a_times_b_plus_c_minus_d -> times_e_squared [label="Multiply", class="Dependencies2"];
        e_squared -> times_e_squared [label="Multiply", class="Dependencies2"];
        minus_d_squared [label="SomeNumber"];
        times_e_squared -> minus_d_squared [label="Subtract", class="Dependencies2"];
        d_squared -> minus_d_squared [label="Subtract", class="Dependencies2"];
        cube_and_change_type [label="AnotherNumber"];
        minus_d_squared -> cube_and_change_type [label="Cube"];
    }
)]
pub struct DagCreator;
// ANCHOR_END: graph_creator

#[serial]
#[test]
#[rustfmt::skip]
fn test_reducing_more_boilerplate() {
use depends::{HashSetVisitor, Resolve};
// ANCHOR: graph_creator_use
// Provide initial values for all of the nodes.
let my_dag = DagCreator::create_my_dag(
    SomeNumber { value: 1 },
    SomeNumber { value: 2 },
    SomeNumber { value: 3 },
    SomeNumber { value: 4 },
    SomeNumber { value: 2 },
    SomeNumber::default(),
    SomeNumber::default(),
    SomeNumber::default(),
    SomeNumber::default(),
    SomeNumber::default(),
    SomeNumber::default(),
    SomeNumber::default(),
    AnotherNumber::default(),
);

let mut visitor = HashSetVisitor::new();

// The graph implements `Resolve`
{
    let output = my_dag.resolve_root(&mut visitor).unwrap();
    assert_eq!(output.value, -64);
}

// There are accessor methods to update inputs
my_dag.update_e(3).unwrap();

let output = my_dag.resolve_root(&mut visitor).unwrap();
assert_eq!(output.value, 1331);
// ANCHOR_END: graph_creator_use
drop(output);

// ANCHOR: send_graph
// We can move the graph to other threads, despite the fact that it holds
// `Rc`s. This is safe because they are private, never cloned until dropped
// and always sent at the _same_ time.
let (my_dag, mut visitor) = std::thread::spawn(|| {
    // The graph provides a safe API for updating all input nodes.
    my_dag.update_c(10).unwrap();
    my_dag.update_b(6).unwrap();
    {
        let output = my_dag.resolve_root(&mut visitor).unwrap();
        assert_eq!(output.value, -4096);
    }
    (my_dag, visitor)
})
    .join()
    .unwrap();

my_dag.update_a(3).unwrap();

let output = my_dag.resolve_root(&mut visitor).unwrap();
assert_eq!(output.value, 778688);
// ANCHOR_END: send_graph
}
