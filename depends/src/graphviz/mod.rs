use std::{
    collections::{hash_map::DefaultHasher, BTreeMap, BTreeSet, HashSet},
    hash::BuildHasher,
};

use crate::core::{Identifiable, Visitor};

#[derive(Debug)]
struct Node {
    id: usize,
    name: &'static str,
    edges: BTreeSet<usize>,
}

/// A [Visitor] which builds a `Graphviz` representation of a given graph.
///
/// ```
/// # use std::{collections::HashSet, hash::Hash, sync::Arc};
/// #
/// # use depends::{
/// #     core::{
/// #         Depends, Dependency, HashValue, Resolve, UpdateDependee, UpdateLeaf,
/// #         NodeHash, LeafNode
/// #     },
/// #     derives::{Dependee, dependencies, Leaf},
/// # };
/// #
/// # // A `Leaf` is a node which takes new values from outside the graph.
/// # #[derive(Leaf, Default, Hash)]
/// # pub struct NumberInput {
/// #     value: i32,
/// # }
/// #
/// # // `Leaf` types must provide a way for code outside to update their internal state.
/// # // This is just a simple replace for now.
/// # impl UpdateLeaf for NumberInput {
/// #     type Input = i32;
/// #
/// #     fn update_mut(&mut self, input: Self::Input) {
/// #         self.value = input;
/// #     }
/// # }
/// #
/// # // `dependencies` are derived to state what references `Dependee` nodes need to
/// # // calculate their state on-demand. These could be any number of other `Dependee`s
/// # // or `Leaf`s.
/// # #[dependencies]
/// # pub struct Components {
/// #     left: LeafNode<NumberInput>,
/// #     right: LeafNode<NumberInput>,
/// # }
/// #
/// # // A `Dependee` i.e. its state is a pure transformation of other nodes
/// # #[derive(Dependee, Default, Hash)]
/// # #[depends(dependencies = Components)]
/// # pub struct Sum {
/// #     value: i32,
/// # }
/// #
/// # // This trait specifies how a `Dependee` updates its internal state given its dependencies.
/// # impl UpdateDependee for Sum {
/// #     fn update_mut(&mut self, input: <Self as Depends>::Input<'_>) {
/// #         // `ComponentsRef` is auto-generated by `dependencies`. It's a read-reference
/// #         // to each field of `Components`
/// #         let ComponentsRef { left, right } = input;
/// #         self.value = left.value + right.value;
/// #     }
/// # }
/// #
/// # struct MyGraph {
/// #     left: Arc<LeafNode<NumberInput>>,
/// #     right: Arc<LeafNode<NumberInput>>,
/// #     // `SumNode` is auto-generated by `Dependee`.
/// #     sum: Arc<SumNode>,
/// # }
/// #
/// use depends::graphviz::GraphvizVisitor;
///
/// // Compose a graph.
/// let left = NumberInput::default().into_leaf();
/// let right = NumberInput::default().into_leaf();
/// let sum = Sum::default().into_node(Components::new(Arc::clone(&left), Arc::clone(&right)));
///
/// let graph = MyGraph { left, right, sum };
///
/// let mut visitor = GraphvizVisitor::new();
///
/// // Resolve the graph with this visitor.
/// // Be sure NOT to use `resolve_root`, as this will clear the visitor's state.
/// graph.sum.resolve(&mut visitor);
///
/// // A Graphviz representation is now available on the visitor!
/// assert_eq!(visitor.render().unwrap(), r#"
/// digraph G {
///   0[label="NumberInput"];
///   1[label="NumberInput"];
///   2[label="Sum"];
///   0 -> 2;
///   1 -> 2;
/// }
/// "#.trim());
/// ```
#[derive(Debug, Default)]
pub struct GraphvizVisitor {
    visitor: HashSet<usize>,
    nodes: BTreeMap<usize, Node>,
    stack: Vec<usize>,
}

impl GraphvizVisitor {
    pub fn new() -> Self {
        Self::default()
    }

    /// Render the visited graph to Graphviz DOT format. Returns [Option::None]
    /// if no graph has been visited.
    pub fn render(&self) -> Option<String> {
        if self.nodes.is_empty() {
            None
        } else {
            let mut lines = Vec::new();
            lines.push(String::from("digraph G {"));
            self.nodes.values().for_each(|n| {
                lines.push(format!("  {}[label=\"{}\"];", n.id, n.name));
                n.edges.iter().for_each(|c| {
                    lines.push(format!("  {} -> {};", c, n.id));
                });
            });
            lines.push(String::from("}"));
            Some(lines.join("\n"))
        }
    }
}

impl Visitor for GraphvizVisitor {
    type Hasher = DefaultHasher;

    fn visit<N>(&mut self, node: &N) -> bool
    where
        N: Identifiable,
    {
        self.visitor.visit(node)
    }

    fn clear(&mut self) {
        self.visitor.clear();
        self.nodes.clear();
    }

    fn touch<N>(&mut self, node: &N)
    where
        N: Identifiable,
    {
        self.stack.push(node.id());
        self.nodes.entry(node.id()).or_insert_with(|| {
            Node {
                id: node.id(),
                name: N::name(),
                edges: BTreeSet::default(),
            }
        });
    }

    fn leave<N>(&mut self, node: &N)
    where
        N: Identifiable,
    {
        let last = self.stack.pop().unwrap();
        assert_eq!(last, node.id());
        if let Some(parent) = self.stack.last() {
            self.nodes.get_mut(parent).map(|n| n.edges.insert(last));
        }
    }

    fn hasher(&self) -> Self::Hasher {
        self.visitor.hasher().build_hasher()
    }
}
